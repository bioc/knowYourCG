---
title: "KnowYourCpG User Guide"
shorttitle: "KnowYourCpG guide"
package: KnowYourCpG
output: rmarkdown::html_vignette
fig_width: 8
fig_height: 6
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{"0. KnowYourCpG User Guide"}
  %\VignetteEncoding{UTF-8}
---

# KnowYourCpG

## Introduction

KnowYourCpG is a package for evaluating CpG feature enrichment using Illumina probe IDs. One such tool in the package automates the hypothesis testing by asking whether a set of CpGs (represented by Illumina methylation chip probes) is enriched in certain categories or features. These categories or features can be categorical (e.g., CpGs related to tissue-specific transcription factors) or continuous (e.g., CpG Island density). Additionally, the set of CpGs to which the test will be applied can be categorical or continuous as well.

The set of CpGs that will be tested for enrichment is called the query set, and the set of CpGs that will be used to determine enrichment of a given factor is called the database set. A query set, for example, might be the results of an epigenome-wide association study. We have taken the time to curate our own database sets from a variety of sources that describe different categorical and continuous features such as transcription factor binding sites, CpG density, technical factors, etc. 

Additionally, knowYourCpG has support for feature selection and feature engineering, which is currently in development. 

## Install KnowYourCpG

To install KnowYourCpG from Bioconductor
```{r install-kycpg-bioconductor, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("KnowYourCpG")
```

To install the development version directly from GitHub
```{r install-kycpg-github, eval=FALSE}
BiocManager::install('zhou-lab/knowYourCpG')
```

## Load KnowYourCpG

First, load the package.

```{r load-kycpg, eval=TRUE, echo=TRUE}
suppressWarnings(library(knowYourCpG))
```

## Input Data

### Database Sets

We have organized our database sets in terms of different releases. The ```listDatabaseSets()``` function lists the database sets in the most recent release. The ```release``` parameter to this function controls which release to list. The user can see the database sets available in Release 2 using the following:

``` {r list-data, eval=TRUE, echo=TRUE}
listDatabaseSets(release=2, dev=TRUE)
```

We have provided the ```getDatabaseSet()``` function that returns a list of database sets identified by their accessions shown in ```listDatabaseSets()```. When this function is ran for the first time, none of the database sets have been cached. Caching on the local machine is important on two fronts: firstly it limits the number of requests sent to our server, and secondly it limits the amount of time the user needs to wait when re-downloading database sets. For this reason, the first time the user runs ```getDatabaseSet()```, it will take some time to download all of the database sets from a given release. The default directory to which the database set will be cached is in knowYourCpGPackage/databaseSets. Additionally, the user may set a global variable KYCG_DATABASESETS_LOC if they wish to specify an alternative directory. Regardless of the initial request to ```getDatabaseSet()```, the entire given Release (identified by the ```release``` parameter) will be cached and stored in a respective sub-directory.

Two global variables, ```KYCG_UNIVERSESETS_LOC``` and ```KYCG_DATABASESETS_LOC```, control where universe sets and database sets will be cached, respectively If either is not set, then then default respective locations in the root of the package will be used. 

``` {r set-options0, eval=TRUE, echo=TRUE}
options(KYCG_UNIVERSESETS_LOC = file.path('..', 'universeSets'))
options(KYCG_DATABASESETS_LOC = file.path('..', 'databaseSets'))
```

Using a subset of the available database sets, we will download them and load them in into memory using their accessions.

``` {r cache-data, eval=TRUE, echo=TRUE}
databaseSetNames = c('20210630_MM285_mm10_CpGDensity',
                     '20210630_MM285_mm10_CGI',
                     '20210816_MM285_mm10_distToTSS',
                     '20210210_MM285_design',
                     '20210630_MM285_mm10_probe_type')

databaseSets = getDatabaseSets(databaseSetNames, dev=TRUE)
```

In total, 40 database sets have been loaded from this command.

``` {r view-data0, eval=TRUE, echo=FALSE}
cat(sprintf("length(databaseSets) = %s database sets", length(databaseSets)))
```

We will show the first three for simplicity.

``` {r view-data1, eval=TRUE, echo=FALSE}
str(databaseSets[1:3])
```

And display a summary of its contents.

``` {r view-data2, eval=TRUE, echo=FALSE}
summary(databaseSets[1:3])
```

On subsequent runs of the ```getDatabaseSet()``` function, loading specific database sets from the same release will be much faster. These database sets will be persistent between R sessions so long as the directory to which they are downloaded is not deleted. Otherwise, the database sets will have to be downloaded again.

### Query Sets

A query set represents probes of interest. It may either be in the form of a character vector where the values correspond to probe IDs or a named numeric vector where the names correspond to probe IDs.

A list of test query sets can be obtained from the following URL. 

```{r cache-data2, eval=TRUE, echo=TRUE}
querySets = readRDS(url("http://zhouserver.research.chop.edu/kyCG/20210726_querySets.rds"))
querySet = querySets[[1]]
```

In total, 26 query sets have been loaded from this command.

``` {r view-data3, eval=TRUE, echo=FALSE}
cat(sprintf("length(querySets) = %s", length(querySets)))
```

We are just going to use the first one, which is a set of hypomethylated probes in Mouse brain tissue from the MM285 array. This specific query set has 50 probes.

``` {r view-data4, eval=TRUE, echo=FALSE}
cat(sprintf("length(querySet) = %s probes", length(querySet)))
```

Using the obtained database sets and query set, the user may analyze their overlap and enrichment. 

## Functionality

There are many functions in this package that make investigating the biological significance of a set of probes easier.

### Obtaining Optional Annotation from each Databse Set 

Using the ```getDatabaseSetOverlap()``` function, the user can investigate the database sets that overlap with the given query set, the degree of overlap, and any provided annotation.

``` {r run-annotation, echo=TRUE, eval=TRUE}
annotation = getDatabaseSetOverlap(querySet, databaseSets)
head(annotation)
```

The ```meta``` column indicates whether the respective database set contains annotation. The ```nQ``` and ```nD``` columns indicate the length of the query set and database set respectively, and the ```overlap``` column indicates the amount of overlap. In some cases, this annotation data.frame will be sparse as not all database sets have the same annotation columns. None of these overlapping database sets have annotation, so no additional columns were returned.

### Investigating the Enrichment of Many Database Sets in a Single Query Set

The ```testEnrichmentAll()``` function is the main work horse to KnowYourCpG. It tests the enrichment of the given database sets in a single query set. There are four testing scenarios depending on the type format of the query set and database sets. They are shown with the respective testing scenario in the table below.

![Four testing scenarios of KnowYourCpG](../20210627_kycpg_tests.png){width=75%}

The ```testEnrichmentAll()``` will automate statistical tests and report metrics about each of the the loaded database sets. Another set that is needed for the test is called the universe set. This is the set of all probes for a given array. It can either be passed in as an argument called ```universeSet``` or the array name can be passed with argument ```array```. If neither of these are supplied, the universe set will be implied from the probes. In all subsequent runs of ```testEnrichmentAll()``` in this vignette, the array will be specified. 

```{r run-test-single, echo=TRUE, eval=TRUE}
resultsAll = testEnrichmentAll(querySet=querySet, 
                               databaseSets=databaseSets, 
                               verbose=FALSE)
print(head(resultsAll))

rank(resultsAll$estimate)

```

The output of each test contains at least four variables: the estimate, p-value, type of test, and whether meta data is included in the tested database set. The name of the database set is also recorded as well. By default, the p-value column is sorted. 

It should be noted that the estimate (or test statistic) is test dependent and comparison between p-values should be limited to within the same type of test. For instance, the test statistics for Fisher's exact test and FGSEA are log fold change and the test statistic for Spearman's test is simply the rank order correlation coefficient. For simplicity, we report all of the test types in one data frame. 

The ```nQ``` and ```nD``` columns identify the length of the query set and the database set, respectively. Often, it's important to examine the extent of overlap between the two sets, so that metric is reported as well in the ```overlap``` column.

Using these results, we can plot a volcano plot and lollipop plot.

```{r plot-volcano, fig.width=7, fig.height=6, echo=TRUE}
plotVolcano(data=resultsAll, title="Database Set Enrichment", 
            subtitle="MM285 Mouse Array")
```

```{r plot-lollipop, fig.width=7, fig.height=6, echo=TRUE}
plotLollipop(data=resultsAll, title="Top Database Set Enrichment", 
             subtitle="MM285 Mouse Array")
```

### Example Testing Scenarios

The querySet may be a named continuous vector. In that case, either a gene enrichment score will be calculated (if the databaseSet is discrete) or a Spearman correlation will be calculated (if the databaseSet is continuous as well). The three other cases are shown below using biologically relevant examples.

To display this functionality, let's load two numeric database sets individually. One is a database set for CpG density and the other is a database set corresponding to the distance of the nearest transcriptional start site (TSS) to each probe.

``` {r run-test-data, echo=TRUE, eval=TRUE}
CpGDensitydatabaseSet = getDatabaseSets('20210630_MM285_mm10_CpGDensity',
                                        verbose=FALSE)
Dist2TSSdatabaseSet = getDatabaseSets('20210816_MM285_mm10_distToTSS',
                                      verbose=FALSE)
```

#### Example 1

Our first test will look at whether the query set is significantly enriched in either of the database sets individually.

``` {r run-test-other1, echo=TRUE, eval=TRUE}
resultsCpGDensity = testEnrichmentAll(querySet=querySet,
                                      databaseSets=CpGDensitydatabaseSet,
                                      array="MM285")
print(resultsCpGDensity)
```

``` {r run-test-other2, echo=TRUE, eval=TRUE}
resultsTSS = testEnrichmentAll(querySet=querySet, 
                               databaseSets=Dist2TSSdatabaseSet, 
                               array="MM285")
print(resultsTSS)
```
Both of the tests result in a p-value greater than 0.05, so there is little evidence to suggest that either of the query set is enriched in either of these database sets. 

#### Example 2

A third test might be whether there is a significant correlation between these two database sets.

``` {r run-test-other3, echo=TRUE, eval=TRUE}
resultsCpGdensityTSS = testEnrichmentAll(querySet=CpGDensitydatabaseSet$CpGDesity50,
                                         databaseSets=Dist2TSSdatabaseSet,
                                         array="MM285")
print(resultsCpGdensityTSS)
```

This test is statistically significant with a p-value less than 0.05 and a moderately weak negative correlation. It is known in biology that the distance to TSS are negatively correlated with CpG islands, which is shown to be the case here from the data as well.

In the above four examples, the database sets were specified explicitly. This is not necessarily needed as the function can load a default set of database sets based a release specified the ```release``` parameter. The default is ```release=2```.

#### Example 3

We may want to look specifically at query our query set is significantly enriched in the set of all Transcription Factor Binding Sites (TFBS). Let's first load in the TFBS database set.

``` {r load-data-tfbs, echo=TRUE, eval=TRUE}
databaseSets = getDatabaseSets("20210817_MM285_TFBS_ENCODE", verbose=FALSE)
```

Next we can actually perform the test.

``` {r run-test-tfbs, echo=TRUE, eval=TRUE}
resultsTFBS = testEnrichmentAll(querySet=querySet, databaseSets=databaseSets,
                                array="MM285", verbose=FALSE)
head(resultsTFBS)
```

Using these sample results, we can plot a volcano plot and lollipop plot.

```{r plot-volcano-tfbs, fig.width=7, fig.height=6, echo=TRUE}
plotVolcano(data=resultsTFBS, title="Transcription Factor Binding Site Enrichment",
            subtitle='MM285 Mouse Array')
```

```{r plot-lollipop-tfbs, fig.width=7, fig.height=6, echo=TRUE}
plotLollipop(data=resultsTFBS, title="Transcription Factor Binding Site Enrichment",
             subtitle='MM285 Mouse Array')
```

### Gene Enrichment Ananlysis

Automating the enrichment test process only works when the number of database sets is small. This is important when targeting all genes as there are tens of thousands of genes on each array array. By testing only those genes that overlap with the query set, we can greatly reduce the number of tests. For this reason, the gene enrichment analysis is a special case of these enrichment tests. We can perform this analysis using the ```testEnrichmentGene()``` function.

``` {r run-test-gene, fig.width=7, fig.height=6, echo=TRUE}
resultsGene = testEnrichmentGene(querySet, array="MM285", verbose=FALSE)
head(resultsGene)
```

Using these sample results, we can plot a volcano plot and lollipop plot.

```{r plot-volcano-gene, fig.width=7, fig.height=6, echo=TRUE}
plotVolcano(data=resultsGene, title="Gene Enrichment",
            subtitle="MM285 Mouse Array", n.fdr=TRUE)
```

```{r plot-lollipop-gene, fig.width=7, fig.height=6, echo=TRUE}
plotLollipop(data=resultsGene, title="Top Gene Enrichment", 
             subtitle="MM285 Mouse Array", n=10)
```

For example, this given query set is tissue specific hypomethylation of mouse brain. Rufy3 is shown to be significantly enriched in this set and it is known to be enriched in neurons (https://www.ncbi.nlm.nih.gov/gene/22902).

## Feature Engineering

In addition to hypothesis testing, knowYourCpG also uses the curated database sets for feature engineering. We have a pre-curated samplesheet and beta value matrix corresponding to about 20 MM285 samples The user can load them in with the following commands.

A third environmental variable, ```KYCG_FEATURE_ENGINEERING_LOC```, controls the location where data related to feature engineering where will be cached.

``` {r run-feature-engineering-get-data, echo=TRUE, eval=TRUE}
options(KYCG_FEATURE_ENGINEERING_LOC = file.path('..', 'featureEngineering'))

samplesheet = getSampleSheet("MM285", release=1, dev=TRUE, verbose=TRUE)
betas = getBetas("MM285", release=1, dev=TRUE, verbose=TRUE)
```

The samplesheet includes a couple UIDs pertaining to the sample and several categorical/numerical features. To use this for a linear model, we will extract the most relevant prevalent features. 

``` {r run-feature-engineering-subsetting-samplesheet, echo=TRUE, eval=TRUE}
samplesheet = samplesheet[, c("meanMeth", "pcgMeth", "Mouse_Age_Months",
                              "Mouse_Age_Days", "Sex", "Strain_Corrected",
                              "Tissue_Corrected", 'Genotype')]
print(head(samplesheet))
```

We have found that it is incredibly computationally expensive to perform a linear model/generalized linear model on a feature set of individual CpGs. Additionally, interpreting the mechanism the significantly contributing CpGs is non-trivial due to their complex interactions. We hope to leverage these pre-curated database sets by using their beta value summary statistics as features instead. 

We will calculate the summary statistics for the betas matrix using a list of database sets.

``` {r run-feature-engineering-statistics}
databaseSets = getDatabaseSets(databaseSetNames, dev=TRUE)
statistics = calcDatabaseSetStatisticsAll(betas, databaseSets=databaseSets)
head(statistics[, 1:5])
```

We will look at the mean of each database set.

``` {r feature-engineering-subsetting-statistics}
statistics = statistics[, grepl("mean", colnames(statistics))]
head(statistics[, 1:5])
```
Just from the few database set means above, we can see that CpG islands are consistently hypomethylated, which is consistent with known biology. 

Using the samplesheet and beta values, we can create a singular data for linear models. Each categorical variable should be caste as a factor with a reference level. Each numerical variable should be expressed appropriately as well.

``` {r feature-engineering-data-curation}
data = cbind(samplesheet, statistics)

data$Sex = relevel(factor(data$Sex), 'Female')
data$Strain_Corrected = relevel(factor(data$Strain_Corrected), '129/Sv')
data$Tissue_Corrected = relevel(factor(data$Tissue_Corrected),  'Colon')
data$Genotype = relevel(factor(data$Genotype), 'WT')

data$Mouse_Age_Days = as.numeric(data$Mouse_Age_Days)
data$Mouse_Age_Months = as.numeric(data$Mouse_Age_Months)
```

A linear model can finally be constructed using this data. Since there are only 20 samples, we will use use four of the database summary statistics.

``` {r feature-engineering-linear-model}
model = lm(Mouse_Age_Days ~ Sex + Strain_Corrected + Tissue_Corrected + 
               Genotype + `CGI-mean` + `CTCF-mean` + `Random-mean` + 
               `SNP-mean` + `SpermMeth-mean` + `VMR-mean`, data=data)

library(stats4)

summary(model)

# model = glm(Tissue_Corrected ~ Sex + Strain_Corrected + Tissue_Corrected + Genotype + `CGI-mean` + `CTCF-mean` + `Random-mean` + `SNP-mean` + `SpermMeth-mean` + `VMR-mean`, family = binomial(), data=data)

# summary(model)
```
```